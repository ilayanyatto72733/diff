/* :[|||]: */

/*-
 * Copyright (c) 2016 Mariusz Zaborski <oshogbo@FreeBSD.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2008-2010, 2015 Robert N. M. Watson
 * Copyright (c) 2012 FreeBSD Foundation
 * All rights reserved.
 *
 * This software was developed at the University of Cambridge Computer
 * Laboratory with support from a grant from Google, Inc.
 *
 * Portions of this software were developed by Pawel Jakub Dawidek under
 * sponsorship from the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2013 FreeBSD Foundation
 *
 * This software was developed by Pawel Jakub Dawidek under sponsorship from
 * the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
  /* $OpenBSD: xmalloc.c,v 1.10 2019/06/28 05:44:09 deraadt Exp $ */
  /*
 * Author: Tatu Ylonen <ylo@cs.hut.fi>
 * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
 *                    All rights reserved
 * Versions of malloc and friends that check their results, and never return
 * failure (they call fatal if they encounter an error).
 *
 * As far as I am concerned, the code I have written for this software
 * can be used freely for any purpose.  Any derived versions of this
 * software must be clearly marked as such, and if the derived work is
 * incompatible with the protocol description in the RFC file, it must be
 * called by a name other than "ssh" or "Secure Shell".
 */
/**
 * @file mkstemp.c
 * Copyright (C) 2013 MinGW.org project
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice, this permission notice, and the following
 * disclaimer shall be included in all copies or substantial portions of
 * the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OF OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright (c) 2007-2014 QLogic Corporation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*	$OpenBSD: fnmatch.h,v 1.8 2005/12/13 00:35:22 millert Exp $	*/
/*	$NetBSD: fnmatch.h,v 1.5 1994/10/26 00:55:53 cgd Exp $	*/

/*-
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)fnmatch.h	8.1 (Berkeley) 6/2/93
 */
/*-
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * Copyright 2018-2020 Alex Richardson <arichardson@FreeBSD.org>
 *
 * This software was developed by SRI International and the University of
 * Cambridge Computer Laboratory (Department of Computer Science and
 * Technology) under DARPA contract HR0011-18-C-0016 ("ECATS"), as part of the
 * DARPA SSITH research programme.
 *
 * This software was developed by SRI International and the University of
 * Cambridge Computer Laboratory under DARPA/AFRL contract (FA8750-10-C-0237)
 * ("CTSRD"), as part of the DARPA CRASH research programme.
 *
 * This work was supported by Innovate UK project 105694, "Digital Security by
 * Design (DSbD) Technology Platform Prototype".
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#pragma once

#ifndef _ERR_H_
#define _ERR_H_

#include<vector>
//#include<string>
//#include<algorithm>
//#include<filesystem>


//#include <stdlib.h>
//#include <stdio.h>
//#include <stdarg.h>
//#include <malloc.h>
#include <io.h>

// mkstemp
//#define WIN32_LEAN_AND_MEAN
//#define _CRT_SECURE_NO_WARNINGS
//#include <fcntl.h>
//#include <wincrypt.h>

#include "unicodelib_encodings.h"

#define MUL_NO_OVERFLOW	((size_t)1 << (sizeof(size_t) * 4))
//typedef SSIZE_T ssize_t;
typedef	long long	ssize_t; // sys/sys/_types.h

#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#define S_ISDIR(m) (((m) & S_IFDIR) == S_IFDIR)
//#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#define S_ISLNK(m) false
#define readlink(path1, buf1, sizeofbuf1) (ssize_t)-1
// O_DIRECTORY may be used to ensure the resulting file descriptor	refers to a directory.

//     when the named file is a symbolic link, in which case lstat() returns information about the
//     link, while stat() returns information about the file the link references.
// +fnmatch fdscandir
#define lstat stat
//#define O_DIRECTORY 0

#ifndef max
# define max(a,b) ((a) > (b) ? (a) : (b))
#endif
#ifndef min
# define min(a,b) ((a) < (b) ? (a) : (b))
#endif
#define MAX max
#define MIN min
#ifndef roundup
#define roundupzz(x, y) (                                \
{                                                      \
        const typeof(y) __y = y;                       \
        (((x) + (__y - 1)) / __y) * __y;               \
}                                                      \
)
#define roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
#endif
#ifndef powerof2
#define powerof2(x) ((((x)-1) & (x)) == 0)
#endif

#define _PATH_DEVNULL "nul" // "NUL" google AI Overview gonna open NUL file instead
// _PATH_TMP
//#define PATH_MAX MAX_PATH
#define PATH_MAX _MAX_PATH
#define STDIN_FILENO 0
#define STDOUT_FILENO _fileno(stdout)
#ifndef __dead2	// <sys/cdefs.h> // MSVC __declspec(noreturn) declared before fn()
//#define __dead2 __attribute__((__noreturn__))
#define __dead2
#endif
#ifdef __dead2
#define NORETURN __dead2
#else
#define NORETURN
#endif /* __dead2 */

// strcpy_s not return size_t
//#define strlcpy(dst, src, siz) strcpy_s(dst, siz, src)
//#define strlcpy(dst, src, siz) strcpy_s(dst, static_cast<rsize_t>(siz), (char *)src)
size_t strlcpy(char* dst, const char* src, size_t dstsize);
size_t strlcpy(char* dst, unsigned char* src, size_t dstsize);
// <string.h>
#define strcasecmp _stricmp
#define strncasecmp _strnicmp
// getdelim(), getline() {getdelim(..., '\n');}
size_t p2roundup(size_t n);
//ssize_t getline(char** linep, size_t* linecapp, FILE* stream); // read_excludes_file()
// freebsd-src-main/lib/libc/amd64/string/strlcat.c
size_t strlcat(char* dst, const char* src, size_t dstsize);
// other freebsd-src-main/lib/libc/amd64/string/strsep.c
char* strsep(char** stringp, const char* delim);


int		 diffreg_new(char*, char*, int, int);
bool	 can_libdiff(int);

//typedef	__int64_t	__off64_t; // sys/sys/_types.h
//off64_t is _off_t https://stackoverflow.com/questions/9073667/where-to-find-the-complete-definition-of-off-t-type
//off_t is int64 readdir() related, then in pred() off_t long
//typedef	uint64_t	__uint64_t;
//typedef	__uint64_t	__dev_t;
//typedef	__dev_t		dev_t;
//typedef	__uint64_t	__ino_t;	/* inode number */
//typedef	__ino_t		ino_t;

#define __BSD_VISIBLE 1

#define	FNM_NOMATCH	1	/* Match failed. */
#define	FNM_NOSYS	2	/* Function not supported (unused). */

#define	FNM_NOESCAPE	0x01	/* Disable backslash escaping. */
#define	FNM_PATHNAME	0x02	/* Slash must be matched by slash. */
#define	FNM_PERIOD	0x04	/* Period must be matched by period. */
#if __BSD_VISIBLE
#define	FNM_LEADING_DIR	0x08	/* Ignore /<tail> after Imatch. */
#define	FNM_CASEFOLD	0x10	/* Case insensitive search. */
#define	FNM_IGNORECASE	FNM_CASEFOLD
#define	FNM_FILE_NAME	FNM_PATHNAME
#endif

int	 fnmatch(const char*, const char*, int);
//#define fnmatch(pattern, string, flags) (FNM_NOMATCH)

#define	DIRBLKSIZ	1024	// dirent.h
//#define DEV_BSHIFT 9 // tied to load avgs // sys/param.h
//#define DEV_BSIZE 512 // (1<<DEV_BSHIFT) // (1<<9)
//#define	DIRBLKSIZ	DEV_BSIZE
#define	UFS_MAXNAMLEN	255

struct	direct {
	uint32_t d_ino;		/* inode number of entry */
	uint16_t d_reclen;		/* length of this record */
	uint8_t  d_type; 		/* file type, see below */
	uint8_t  d_namlen;		/* length of string in d_name */
	char	  d_name[UFS_MAXNAMLEN + 1];
	/* name with length <= UFS_MAXNAMLEN */
};

/*
 * File types
 */
#define	DT_UNKNOWN	 0
#define	DT_FIFO		 1
#define	DT_CHR		 2
#define	DT_DIR		 4
#define	DT_BLK		 6
#define	DT_REG		 8
#define	DT_LNK		10
#define	DT_SOCK		12
#define	DT_WHT		14

// <sys/dirent.h>
struct dirent {
	uint64_t d_fileno; //ino_t      d_fileno;		/* file number of entry */
	uint64_t d_off;    //off_t      d_off;		/* directory offset of next entry */
	uint16_t d_reclen;		/* length of this record */
	uint8_t	 d_type;		/* file type, see below */
	uint8_t  d_pad0;
	uint16_t d_namlen;		/* length of string in d_name */
	uint16_t d_pad1;
#if __BSD_VISIBLE
#define	MAXNAMLEN	255
	char	d_name[MAXNAMLEN + 1];	/* name must be no longer than this */
#else
	char	d_name[255 + 1];	/* name must be no longer than this */
#endif
};


#include "sys_queue.h"
struct ddloc_mem {
	LIST_ENTRY(ddloc_mem) loc_lqe; /* entry in list */
	size_t	loc_index;	/* key associated with structure */
	off_t	loc_seek;	/* magic cookie returned by getdirentries */
	size_t	loc_loc;	/* offset of entry in buffer */
};
struct _telldir {
	LIST_HEAD(, ddloc_mem) td_locq; /* list of locations */
	long	td_loccnt;	/* index of entry for sequential readdir's */
};
#define	RDU_SKIP	0x0001
#define	RDU_SHORT	0x0002

#define IN_RTLD 666
// 
struct _dirdesc {
	int		dd_fd;		/* file descriptor associated with directory */
	size_t	dd_loc;		/* offset in current buffer */
	size_t	dd_size;	/* amount of data returned by getdirentries */
	char*	dd_buf;		/* data buffer */
	int		dd_len;		/* size of data buffer */
	off_t	dd_seek;	/* magic cookie returned by getdirentries */
	int		dd_flags;	/* flags for readdir */
#ifndef IN_RTLD
	struct pthread_mutex* dd_lock;	/* lock */
#else
	struct _donotuse* dd_lock; /* unused in rtld, keep same layout */
#endif
	struct _telldir* dd_td;	/* telldir position recording */
	void* dd_compat_de;	/* compat dirent */
};

/*
 * The _GENERIC_DIRSIZ macro gives the minimum record length which will hold
 * the directory	entry.	This returns the amount	of space in struct direct
 * without the d_name field, plus enough	space for the name with	a terminating
 * null byte (dp->d_namlen+1), rounded up to a 8	byte boundary.
 *
 * XXX although this macro is in	the implementation namespace, it requires
 * a manifest constant that is not.
 */
#define	MAXNAMLEN	255
//#define MAXNAMLEN		NAME_MAX
//#define	_GENERIC_DIRLEN(namlen)	((__offsetof(struct dirent, d_name) + (namlen) + 1 + 7) & ~7)
#define	_GENERIC_DIRLEN(namlen)	((offsetof(struct dirent, d_name) + (namlen) + 1 + 7) & ~7)
#define	_GENERIC_DIRSIZ(dp)	_GENERIC_DIRLEN((dp)->d_namlen)
#define	_GENERIC_MINDIRSIZ	_GENERIC_DIRLEN(1) /* Name must not be empty */
#define	_GENERIC_MAXDIRSIZ	_GENERIC_DIRLEN(MAXNAMLEN)

#define	_dirfd(dirp)	((dirp)->dd_fd)
typedef struct _dirdesc DIR;

/* flags for opendir2 */
#define DTF_HIDEW	0x0001	/* hide whiteout entries */
#define DTF_NODUP	0x0002	/* don't return duplicate names */
#define DTF_REWIND	0x0004	/* rewind after reading union stack */
#define __DTF_READALL	0x0008	/* everything has been read */
#define	__DTF_SKIPREAD	0x0010  /* assume internal buffer is populated */

#define	SELECT(x)	select(x)

static int scandir_thunk_cmp(const void* p1, const void* p2, void* thunk);
//typedef int		 cmp_t(void*, const void*, const void*);
//typedef int		 cmp_t(const void*, const void*);
typedef int		 cmp_t(const struct dirent**, const struct dirent**);
static inline char* med3(char*, char*, char*, cmp_t*, void*);
//static inline char* med3(char*, char*, char*, cmp_t*, void*);
//static inline void	 swapfunc(char*, char*, size_t, int, int);

// block_abi.h
#define	DECLARE_BLOCK(retTy, name, argTys, ...)\
	struct {\
		void *isa;\
		int flags;\
		int reserved;\
		retTy (*invoke)(void *, ...);\
	} *name
#define CALL_BLOCK(name, ...) (name)->invoke(name, __VA_ARGS__)

#define GET_BLOCK_FUNCTION(x) \
	(((struct {\
		void *isa;\
		int flags;\
		int reserved;\
		void (*invoke)(void *, ...);\
	}*)(void*)x)->invoke)

int	 alphasort(const struct dirent**, const struct dirent**);

//#define fdscandir(fd, dirp, selectf, comparf) -1
//#define fdscandir(fd, dirp, selectf, comparf) 0
int fdscandir(const std::wstring&, struct dirent***, int (*)(const struct dirent*), int (*)(const struct dirent**, const struct dirent**));
//int fdscandir(int, struct dirent***, int (*)(const struct dirent*), int (*)(const struct dirent**, const struct dirent**));

//#define	likely(x) __predict_true(x)
//#define	unlikely(x) __predict_false(x)
#define __predict_false(arg) (arg)
inline void qsort_r(void* base, size_t nmemb, size_t size,
							void* thunk, int (*compar)(const struct dirent**, const struct dirent**));
						   //void* thunk, int (*compar)(void*, const void*, const void*));

std::string wstring2string(const std::wstring& in_str);
std::wstring string2wstring(const std::string& in_str);
DWORD getnsec(const std::string& f);



// https://stackoverflow.com/questions/6036227/mkstemp-implementation-for-win32

//#define __MKSTEMP_INLINE  static __inline__ __attribute__((__always_inline__))
//int __cdecl __mingw_mkstemp(char*);
//#define CRYPTO_INLINE  static __inline__ __attribute__((__always_inline__))
//CRYPTO_INLINE
//#define RSA_MODE( OPT, FLAG )  PROV_RSA_##OPT, CRYPT_##FLAG

inline HCRYPTPROV crypto_provider(void);
inline void* crypto_randomize(void* buf, DWORD buflen);
inline unsigned char* crypto_random_filename_char(unsigned char* caret);
char* crypto_tmpname(char* tmplt);
inline int __mingw_mkstemp(char* tmplt);
int mkstemp(char* __name_template);
//inline int __cdecl mkstemp(char* __name_template);



struct pr {
	int ostdout;
	int kq;
	struct kevent* e;
};

struct pr* start_pr(char* file1, char* file2);
void stop_pr(struct pr*);


#ifndef _SYS_CAPRIGHTS_H_
#define	_SYS_CAPRIGHTS_H_

#define	CAP_RIGHTS_VERSION_00	0
#define	CAP_RIGHTS_VERSION	CAP_RIGHTS_VERSION_00

struct cap_rights {
	uint64_t	cr_rights[CAP_RIGHTS_VERSION + 2];
};

#ifndef	_CAP_RIGHTS_T_DECLARED
#define	_CAP_RIGHTS_T_DECLARED
typedef	struct cap_rights	cap_rights_t;
#endif

#endif /* !_SYS_CAPRIGHTS_H_ */
#ifndef _SYS_CAPSICUM_H_
#define	_SYS_CAPSICUM_H_

#define	CAPRIGHT(idx, bit)	((1ULL << (57 + (idx))) | (bit))
/*
 * General file I/O.
 */
 /* Allows for openat(O_RDONLY), read(2), readv(2). */
#define	CAP_READ		CAPRIGHT(0, 0x0000000000000001ULL)
/* Allows for openat(O_WRONLY | O_APPEND), write(2), writev(2). */
#define	CAP_WRITE		CAPRIGHT(0, 0x0000000000000002ULL)
/* Allows for lseek(fd, 0, SEEK_CUR). */
#define	CAP_SEEK_TELL		CAPRIGHT(0, 0x0000000000000004ULL)
/* Allows for lseek(2). */
#define	CAP_SEEK		(CAP_SEEK_TELL | 0x0000000000000008ULL)
/* Allows for aio_read(2), pread(2), preadv(2). */
#define	CAP_PREAD		(CAP_SEEK | CAP_READ)
/*
 * Allows for aio_write(2), openat(O_WRONLY) (without O_APPEND), pwrite(2),
 * pwritev(2).
 */
#define	CAP_PWRITE		(CAP_SEEK | CAP_WRITE)
 /* Allows for mmap(PROT_NONE). */
#define	CAP_MMAP		CAPRIGHT(0, 0x0000000000000010ULL)
/* Allows for mmap(PROT_READ). */
#define	CAP_MMAP_R		(CAP_MMAP | CAP_SEEK | CAP_READ)
/* Allows for mmap(PROT_WRITE). */
#define	CAP_MMAP_W		(CAP_MMAP | CAP_SEEK | CAP_WRITE)
/* Allows for mmap(PROT_EXEC). */
#define	CAP_MMAP_X		(CAP_MMAP | CAP_SEEK | 0x0000000000000020ULL)
/* Allows for mmap(PROT_READ | PROT_WRITE). */
#define	CAP_MMAP_RW		(CAP_MMAP_R | CAP_MMAP_W)
/* Allows for mmap(PROT_READ | PROT_EXEC). */
#define	CAP_MMAP_RX		(CAP_MMAP_R | CAP_MMAP_X)
/* Allows for mmap(PROT_WRITE | PROT_EXEC). */
#define	CAP_MMAP_WX		(CAP_MMAP_W | CAP_MMAP_X)
/* Allows for mmap(PROT_READ | PROT_WRITE | PROT_EXEC). */
#define	CAP_MMAP_RWX		(CAP_MMAP_R | CAP_MMAP_W | CAP_MMAP_X)
/* Allows for openat(O_CREAT). */
#define	CAP_CREATE		CAPRIGHT(0, 0x0000000000000040ULL)
/* Allows for openat(O_EXEC) and fexecve(2) in turn. */
#define	CAP_FEXECVE		CAPRIGHT(0, 0x0000000000000080ULL)
/* Allows for openat(O_SYNC), openat(O_FSYNC), fsync(2), aio_fsync(2). */
#define	CAP_FSYNC		CAPRIGHT(0, 0x0000000000000100ULL)
/* Allows for openat(O_TRUNC), ftruncate(2). */
#define	CAP_FTRUNCATE		CAPRIGHT(0, 0x0000000000000200ULL)

/* Lookups - used to constrain *at() calls. */
#define	CAP_LOOKUP		CAPRIGHT(0, 0x0000000000000400ULL)

/* VFS methods. */
/* Allows for fchdir(2). */
#define	CAP_FCHDIR		CAPRIGHT(0, 0x0000000000000800ULL)
/* Allows for fchflags(2). */
#define	CAP_FCHFLAGS		CAPRIGHT(0, 0x0000000000001000ULL)
/* Allows for fchflags(2) and chflagsat(2). */
#define	CAP_CHFLAGSAT		(CAP_FCHFLAGS | CAP_LOOKUP)
/* Allows for fchmod(2). */
#define	CAP_FCHMOD		CAPRIGHT(0, 0x0000000000002000ULL)
/* Allows for fchmod(2) and fchmodat(2). */
#define	CAP_FCHMODAT		(CAP_FCHMOD | CAP_LOOKUP)
/* Allows for fchown(2). */
#define	CAP_FCHOWN		CAPRIGHT(0, 0x0000000000004000ULL)
/* Allows for fchown(2) and fchownat(2). */
#define	CAP_FCHOWNAT		(CAP_FCHOWN | CAP_LOOKUP)
/* Allows for fcntl(2). */
#define	CAP_FCNTL		CAPRIGHT(0, 0x0000000000008000ULL)
/*
 * Allows for flock(2), openat(O_SHLOCK), openat(O_EXLOCK),
 * fcntl(F_SETLK_REMOTE), fcntl(F_SETLKW), fcntl(F_SETLK), fcntl(F_GETLK).
 */
#define	CAP_FLOCK		CAPRIGHT(0, 0x0000000000010000ULL)
 /* Allows for fpathconf(2). */
#define	CAP_FPATHCONF		CAPRIGHT(0, 0x0000000000020000ULL)
/* Allows for UFS background-fsck operations. */
#define	CAP_FSCK		CAPRIGHT(0, 0x0000000000040000ULL)
/* Allows for fstat(2). */
#define	CAP_FSTAT		CAPRIGHT(0, 0x0000000000080000ULL)
/* Allows for fstat(2), fstatat(2) and faccessat(2). */
#define	CAP_FSTATAT		(CAP_FSTAT | CAP_LOOKUP)
/* Allows for fstatfs(2). */
#define	CAP_FSTATFS		CAPRIGHT(0, 0x0000000000100000ULL)
/* Allows for futimens(2) and futimes(2). */
#define	CAP_FUTIMES		CAPRIGHT(0, 0x0000000000200000ULL)
/* Allows for futimens(2), futimes(2), futimesat(2) and utimensat(2). */
#define	CAP_FUTIMESAT		(CAP_FUTIMES | CAP_LOOKUP)
/* Allows for linkat(2) (target directory descriptor). */
#define	CAP_LINKAT_TARGET	(CAP_LOOKUP | 0x0000000000400000ULL)
/* Allows for mkdirat(2). */
#define	CAP_MKDIRAT		(CAP_LOOKUP | 0x0000000000800000ULL)
/* Allows for mkfifoat(2). */
#define	CAP_MKFIFOAT		(CAP_LOOKUP | 0x0000000001000000ULL)
/* Allows for mknodat(2). */
#define	CAP_MKNODAT		(CAP_LOOKUP | 0x0000000002000000ULL)
/* Allows for renameat(2) (source directory descriptor). */
#define	CAP_RENAMEAT_SOURCE	(CAP_LOOKUP | 0x0000000004000000ULL)
/* Allows for symlinkat(2). */
#define	CAP_SYMLINKAT		(CAP_LOOKUP | 0x0000000008000000ULL)
/*
 * Allows for unlinkat(2) and renameat(2) if destination object exists and
 * will be removed.
 */
#define	CAP_UNLINKAT		(CAP_LOOKUP | 0x0000000010000000ULL)

 /* Socket operations. */
 /* Allows for accept(2) and accept4(2). */
#define	CAP_ACCEPT		CAPRIGHT(0, 0x0000000020000000ULL)
/* Allows for bind(2). */
#define	CAP_BIND		CAPRIGHT(0, 0x0000000040000000ULL)
/* Allows for connect(2). */
#define	CAP_CONNECT		CAPRIGHT(0, 0x0000000080000000ULL)
/* Allows for getpeername(2). */
#define	CAP_GETPEERNAME		CAPRIGHT(0, 0x0000000100000000ULL)
/* Allows for getsockname(2). */
#define	CAP_GETSOCKNAME		CAPRIGHT(0, 0x0000000200000000ULL)
/* Allows for getsockopt(2). */
#define	CAP_GETSOCKOPT		CAPRIGHT(0, 0x0000000400000000ULL)
/* Allows for listen(2). */
#define	CAP_LISTEN		CAPRIGHT(0, 0x0000000800000000ULL)
/* Allows for sctp_peeloff(2). */
#define	CAP_PEELOFF		CAPRIGHT(0, 0x0000001000000000ULL)
#define	CAP_RECV		CAP_READ
#define	CAP_SEND		CAP_WRITE
/* Allows for setsockopt(2). */
#define	CAP_SETSOCKOPT		CAPRIGHT(0, 0x0000002000000000ULL)
/* Allows for shutdown(2). */
#define	CAP_SHUTDOWN		CAPRIGHT(0, 0x0000004000000000ULL)

/* Allows for bindat(2) on a directory descriptor. */
#define	CAP_BINDAT		(CAP_LOOKUP | 0x0000008000000000ULL)
/* Allows for connectat(2) on a directory descriptor. */
#define	CAP_CONNECTAT		(CAP_LOOKUP | 0x0000010000000000ULL)

/* Allows for linkat(2) (source directory descriptor). */
#define	CAP_LINKAT_SOURCE	(CAP_LOOKUP | 0x0000020000000000ULL)
/* Allows for renameat(2) (target directory descriptor). */
#define	CAP_RENAMEAT_TARGET	(CAP_LOOKUP | 0x0000040000000000ULL)

/* Allows for fchroot(2). */
#define	CAP_FCHROOT		CAPRIGHT(0, 0x0000080000000000ULL)

#define	CAP_SOCK_CLIENT \
	(CAP_CONNECT | CAP_GETPEERNAME | CAP_GETSOCKNAME | CAP_GETSOCKOPT | \
	 CAP_PEELOFF | CAP_RECV | CAP_SEND | CAP_SETSOCKOPT | CAP_SHUTDOWN)
#define	CAP_SOCK_SERVER \
	(CAP_ACCEPT | CAP_BIND | CAP_GETPEERNAME | CAP_GETSOCKNAME | \
	 CAP_GETSOCKOPT | CAP_LISTEN | CAP_PEELOFF | CAP_RECV | CAP_SEND | \
	 CAP_SETSOCKOPT | CAP_SHUTDOWN)

/* All used bits for index 0. */
#define	CAP_ALL0		CAPRIGHT(0, 0x00000FFFFFFFFFFFULL)

/* Available bits for index 0. */
#define	CAP_UNUSED0_57		CAPRIGHT(0, 0x0100000000000000ULL)

/* INDEX 1 */

/* Mandatory Access Control. */
/* Allows for mac_get_fd(3). */
#define	CAP_MAC_GET		CAPRIGHT(1, 0x0000000000000001ULL)
/* Allows for mac_set_fd(3). */
#define	CAP_MAC_SET		CAPRIGHT(1, 0x0000000000000002ULL)

/* Methods on semaphores. */
#define	CAP_SEM_GETVALUE	CAPRIGHT(1, 0x0000000000000004ULL)
#define	CAP_SEM_POST		CAPRIGHT(1, 0x0000000000000008ULL)
#define	CAP_SEM_WAIT		CAPRIGHT(1, 0x0000000000000010ULL)

/* Allows select(2) and poll(2) on descriptor. */
#define	CAP_EVENT		CAPRIGHT(1, 0x0000000000000020ULL)
/* Allows for kevent(2) on kqueue descriptor with eventlist != NULL. */
#define	CAP_KQUEUE_EVENT	CAPRIGHT(1, 0x0000000000000040ULL)

/* Strange and powerful rights that should not be given lightly. */
/* Allows for ioctl(2). */
#define	CAP_IOCTL		CAPRIGHT(1, 0x0000000000000080ULL)
#define	CAP_TTYHOOK		CAPRIGHT(1, 0x0000000000000100ULL)

/* Process management via process descriptors. */
/* Allows for pdgetpid(2). */
#define	CAP_PDGETPID		CAPRIGHT(1, 0x0000000000000200ULL)
/*
 * Allows for pdwait4(2).
 *
 * XXX: this constant was imported unused, but is targeted to be implemented
 *      in the future (bug 235871).
 */
#define	CAP_PDWAIT		CAPRIGHT(1, 0x0000000000000400ULL)
 /* Allows for pdkill(2). */
#define	CAP_PDKILL		CAPRIGHT(1, 0x0000000000000800ULL)

/* Extended attributes. */
/* Allows for extattr_delete_fd(2). */
#define	CAP_EXTATTR_DELETE	CAPRIGHT(1, 0x0000000000001000ULL)
/* Allows for extattr_get_fd(2). */
#define	CAP_EXTATTR_GET		CAPRIGHT(1, 0x0000000000002000ULL)
/* Allows for extattr_list_fd(2). */
#define	CAP_EXTATTR_LIST	CAPRIGHT(1, 0x0000000000004000ULL)
/* Allows for extattr_set_fd(2). */
#define	CAP_EXTATTR_SET		CAPRIGHT(1, 0x0000000000008000ULL)

/* Access Control Lists. */
/* Allows for acl_valid_fd_np(3). */
#define	CAP_ACL_CHECK		CAPRIGHT(1, 0x0000000000010000ULL)
/* Allows for acl_delete_fd_np(3). */
#define	CAP_ACL_DELETE		CAPRIGHT(1, 0x0000000000020000ULL)
/* Allows for acl_get_fd(3) and acl_get_fd_np(3). */
#define	CAP_ACL_GET		CAPRIGHT(1, 0x0000000000040000ULL)
/* Allows for acl_set_fd(3) and acl_set_fd_np(3). */
#define	CAP_ACL_SET		CAPRIGHT(1, 0x0000000000080000ULL)

/* Allows for kevent(2) on kqueue descriptor with changelist != NULL. */
#define	CAP_KQUEUE_CHANGE	CAPRIGHT(1, 0x0000000000100000ULL)

#define	CAP_KQUEUE		(CAP_KQUEUE_EVENT | CAP_KQUEUE_CHANGE)

/* Allows operations on inotify descriptors. */
#define	CAP_INOTIFY_ADD		CAPRIGHT(1, 0x0000000000200000ULL)
#define	CAP_INOTIFY_RM		CAPRIGHT(1, 0x0000000000400000ULL)

/* All used bits for index 1. */
#define	CAP_ALL1		CAPRIGHT(1, 0x00000000007FFFFFULL)

/* Available bits for index 1. */
#define	CAP_UNUSED1_22		CAPRIGHT(1, 0x0000000000800000ULL)
/* ... */
#define	CAP_UNUSED1_57		CAPRIGHT(1, 0x0100000000000000ULL)

/* Backward compatibility. */
#define	CAP_POLL_EVENT		CAP_EVENT

#define	CAP_ALL(rights)		do {					\
	(rights)->cr_rights[0] =					\
	    ((uint64_t)CAP_RIGHTS_VERSION << 62) | CAP_ALL0;		\
	(rights)->cr_rights[1] = CAP_ALL1;				\
} while (0)

#define	CAP_NONE(rights)	do {					\
	(rights)->cr_rights[0] =					\
	    ((uint64_t)CAP_RIGHTS_VERSION << 62) | CAPRIGHT(0, 0ULL);	\
	(rights)->cr_rights[1] = CAPRIGHT(1, 0ULL);			\
} while (0)

#define	CAPRVER(right)		((int)((right) >> 62))
#define	CAPVER(rights)		CAPRVER((rights)->cr_rights[0])
#define	CAPARSIZE(rights)	(CAPVER(rights) + 2)
#define	CAPIDXBIT(right)	((int)(((right) >> 57) & 0x1F))

/*
 * Allowed fcntl(2) commands.
 */
#define	CAP_FCNTL_GETFL		(1 << F_GETFL)
#define	CAP_FCNTL_SETFL		(1 << F_SETFL)
#define	CAP_FCNTL_GETOWN	(1 << F_GETOWN)
#define	CAP_FCNTL_SETOWN	(1 << F_SETOWN)
#define	CAP_FCNTL_ALL		(CAP_FCNTL_GETFL | CAP_FCNTL_SETFL | \
				 CAP_FCNTL_GETOWN | CAP_FCNTL_SETOWN)

#define	CAP_IOCTLS_ALL	SSIZE_MAX

#define	cap_rights_init(...)						\
	__cap_rights_init(CAP_RIGHTS_VERSION, __VA_ARGS__, 0ULL)
cap_rights_t* __cap_rights_init(int version, cap_rights_t * rights, ...);

#define	cap_rights_set(...)						\
	__cap_rights_set(__VA_ARGS__, 0ULL)
cap_rights_t* __cap_rights_set(cap_rights_t* rights, ...);

#define	cap_rights_clear(...)						\
	__cap_rights_clear(__VA_ARGS__, 0ULL)
cap_rights_t* __cap_rights_clear(cap_rights_t* rights, ...);

#define	cap_rights_is_set(...)						\
	__cap_rights_is_set(__VA_ARGS__, 0ULL)
bool __cap_rights_is_set(const cap_rights_t* rights, ...);

bool cap_rights_is_empty(const cap_rights_t* rights);

bool cap_rights_is_valid(const cap_rights_t* rights);
cap_rights_t* cap_rights_merge(cap_rights_t* dst, const cap_rights_t* src);
cap_rights_t* cap_rights_remove(cap_rights_t* dst, const cap_rights_t* src);

const cap_rights_t* cap_rights_fde(const struct filedescent* fde);
const cap_rights_t* cap_rights(struct filedesc* fdp, int fd);

#endif /* !_SYS_CAPSICUM_H_ */

#ifndef _CAPSICUM_HELPERS_H_
#define	_CAPSICUM_HELPERS_H_

static __inline int
caph_rights_limit(int fd, const cap_rights_t* rights) {
	return (0);
}
static __inline int
caph_limit_stderr(void) {
	return (0);
}
static __inline int
caph_limit_stdout(void) {
	return (0);
}
static __inline int
caph_limit_stdio(void) {
	return (0);
}
static __inline void
caph_cache_catpages(void) {
}
static __inline void
caph_cache_tzdata(void) {
}
static __inline int
caph_enter(void) {
	return (0);
}

#endif /* _CAPSICUM_HELPERS_H_ */

template<typename... Targs>
void oo_omegaprntc(const std::string& format, Targs... Fargs) {
	long long size = _scprintf(format.c_str(), Fargs ...); // long long can return -1, not count EOL
	//size_t size = _snwprintf_s(nullptr, null, 0, format.c_str(), Fargs ...) + 1; // Extra space for '\0' // ?double EOL, anyway this fn() call is bad
	if (size <= 0) { printf("oo_omegaprntc() critical error: %s", format.c_str()); exit(666); } // add log
	std::vector<char> buf((size + 4), '\0'); // wchar_t(0) 
	_snprintf_s(buf.data(), buf.size(), size, format.c_str(), Fargs ...); // <stdio.h>
	if (std::find(buf.begin(), buf.end(), '\n') != buf.end()) {
		printf("%s", buf.data());
	} else {
		printf("%s\n", buf.data()); // todo: remove extra output
	}
}

template<typename... Targs>
void err(int eval, const std::string& format, Targs... Fargs) {
	printf("err: %d, ", eval);
	oo_omegaprntc(format.c_str(), Fargs ...);
	exit(eval);
}

template<typename... Targs>
void errx(int eval, const std::string& format, Targs... Fargs) {
	printf("errx: %d, ", eval);
	oo_omegaprntc(format.c_str(), Fargs ...);
	exit(eval);
}

template<typename... Targs>
void errc(int eval, int errc, const std::string& format, Targs... Fargs) {
	printf("errc: %d, %d, ", eval, errc);
	std::string tmp = "errcode " + std::to_string(errc) + " " + format;
	oo_omegaprntc(tmp.c_str(), Fargs ...);
	exit(eval);
}

template<typename... Targs>
void warn(const std::string& format, Targs... Fargs) { // void	warn(const char *, ...) __printf0like(1, 2);
	printf("warn: "); // todo: remove extra output
	oo_omegaprntc(format.c_str(), Fargs ...);
}

template<typename... Targs>
void warnc(int errc, const std::string& format, Targs... Fargs) {
	printf("warnc: %d: ", errc); // todo: remove extra output
	oo_omegaprntc(format.c_str(), Fargs ...);
}

template<typename... Targs>
void warnx(const std::string& format, Targs... Fargs) { // void	warnx(const char *, ...) __printflike(1, 2);
	printf("warnx: "); // todo: remove extra output
	oo_omegaprntc(format.c_str(), Fargs ...);
}

void* xmalloc(size_t size);

char* xstrdup(const char* str);

void* xcalloc(size_t nmemb, size_t size);

void* reallocarray(void* optr, size_t nmemb, size_t size);

void* xreallocarray(void* ptr, size_t nmemb, size_t size);

int vasprintf(char** strp, const char* fmt, va_list ap);

int asprintf(char** strp, const char* fmt, ...);

int xasprintf(char** ret, const char* fmt, ...);

int pread(int fd, void* buf, size_t nbytes, off_t offset);

#endif